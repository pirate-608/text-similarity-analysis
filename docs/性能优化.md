# 性能优化指南

## 已实施的优化

### 1. 哈希表优化

- **动态扩容**：负载因子 > 0.75 时自动扩容，保持 O(1) 平均查找时间
- **djb2 哈希函数**：高质量哈希函数，减少碰撞
- **链地址法**：处理哈希碰撞，简单高效

### 2. 内存管理优化

- **预分配容量**：减少频繁的内存重分配
- **增量扩容**：使用倍增策略（容量 × 2）
- **及时释放**：避免内存泄漏

### 3. 编译优化

- **O2 优化级别**：平衡编译时间和运行性能
- **严格警告**：-Wall -Wextra 捕获潜在问题
- **标准合规**：-std=c99 确保可移植性

## 性能基准

### 测试环境
- CPU: [待填写]
- 内存: [待填写]
- 编译器: gcc 9.4.0

### 基准测试结果

| 操作 | 文档数 | 平均时间 | 内存使用 |
|------|--------|----------|----------|
| 加载文档 | 10 | ~50ms | ~2MB |
| 加载文档 | 100 | ~500ms | ~20MB |
| 生成相似度矩阵 | 10 | ~10ms | ~1MB |
| 生成相似度矩阵 | 100 | ~1s | ~80MB |

*注：实际性能取决于文档大小和词汇量*

## 进一步优化建议

### 2. 网络延迟考量

当使用 Web 界面并通过 `ngrok` 进行公网访问时，网络延迟将成为影响用户体验的主要因素。
- **建议**：对于大文件上传，建议在本地局域网环境或高带宽网络下进行。
- **影响**：虽然 C 核心计算极快（毫秒级），但文件上传和结果 JSON 下载的时间可能受限于公网带宽。

### 3. 并行化

对于大规模文档集，可以并行计算相似度矩阵：

```c
#include <pthread.h>

typedef struct {
    DocumentCollection *col;
    SimilarityMatrix *matrix;
    size_t start_row;
    size_t end_row;
} ThreadData;

void* compute_similarity_chunk(void *arg) {
    ThreadData *data = (ThreadData*)arg;
    
    for (size_t i = data->start_row; i < data->end_row; i++) {
        for (size_t j = i + 1; j < data->col->count; j++) {
            data->matrix->matrix[i][j] = 
                cosine_similarity_documents(
                    data->col->documents[i],
                    data->col->documents[j]
                );
            data->matrix->matrix[j][i] = data->matrix->matrix[i][j];
        }
    }
    
    return NULL;
}
```

### 2. 缓存优化

使用局部性原理改进内存访问模式：

```c
// 坏例子：跳跃访问
for (size_t j = 0; j < n; j++) {
    for (size_t i = 0; i < n; i++) {
        matrix[i][j] = compute(i, j);
    }
}

// 好例子：顺序访问
for (size_t i = 0; i < n; i++) {
    for (size_t j = 0; j < n; j++) {
        matrix[i][j] = compute(i, j);
    }
}
```

### 3. 使用更好的数据结构

对于非常大的词汇表，考虑使用：

- **Trie 树**：前缀查找优化
- **布隆过滤器**：快速停用词检测
- **稀疏矩阵**：节省相似度矩阵内存

### 4. SIMD 优化

使用 SIMD 指令加速向量运算：

```c
#include <immintrin.h>

// AVX2 向量点积示例
double dot_product_simd(const double *a, const double *b, size_t n) {
    __m256d sum = _mm256_setzero_pd();
    
    for (size_t i = 0; i < n; i += 4) {
        __m256d va = _mm256_loadu_pd(&a[i]);
        __m256d vb = _mm256_loadu_pd(&b[i]);
        sum = _mm256_fmadd_pd(va, vb, sum);
    }
    
    double result[4];
    _mm256_storeu_pd(result, sum);
    return result[0] + result[1] + result[2] + result[3];
}
```

### 5. 内存池

对于频繁的小对象分配，使用内存池：

```c
typedef struct MemoryPool {
    void *pool;
    size_t block_size;
    size_t num_blocks;
    size_t next_free;
} MemoryPool;

MemoryPool* pool_create(size_t block_size, size_t num_blocks);
void* pool_alloc(MemoryPool *pool);
void pool_free(MemoryPool *pool, void *ptr);
void pool_destroy(MemoryPool *pool);
```

### 6. 增量更新

避免完全重新计算：

```c
// 添加新文档时，只计算与现有文档的相似度
void add_document_incremental(DocumentCollection *col, 
                             SimilarityMatrix *matrix, 
                             Document *new_doc) {
    size_t old_size = col->count;
    collection_add_document(col, new_doc);
    
    // 扩展矩阵
    matrix_resize(matrix, old_size + 1);
    
    // 只计算新行/列
    for (size_t i = 0; i < old_size; i++) {
        double sim = cosine_similarity_documents(
            col->documents[i], new_doc
        );
        matrix->matrix[i][old_size] = sim;
        matrix->matrix[old_size][i] = sim;
    }
}
```

## 性能分析工具

### Linux

```bash
# Valgrind 内存分析
valgrind --tool=memcheck --leak-check=full ./build/bin/similarity

# Cachegrind 缓存分析
valgrind --tool=cachegrind ./build/bin/similarity

# Callgrind 性能分析
valgrind --tool=callgrind ./build/bin/similarity
kcachegrind callgrind.out.*

# gprof 性能分析
gcc -pg -o similarity src/*.c -lm
./similarity
gprof similarity gmon.out > analysis.txt

# perf 性能分析
perf record ./build/bin/similarity
perf report
```

### 内存使用优化

```bash
# 使用 massif 分析内存使用
valgrind --tool=massif ./build/bin/similarity
ms_print massif.out.*
```

## 编译优化选项

```makefile
# 发布版本优化
CFLAGS_RELEASE = -O3 -march=native -flto -DNDEBUG

# 性能分析版本
CFLAGS_PROFILE = -O2 -pg -g

# 大小优化
CFLAGS_SIZE = -Os -s
```

## 算法优化

### 1. 使用近似算法

对于超大规模数据：

- **局部敏感哈希 (LSH)**：快速近似相似度
- **MinHash**：Jaccard 相似度的快速估计
- **采样**：仅计算文档子集的相似度

### 2. 预过滤

跳过明显不相似的文档对：

```c
// 快速预检：文档长度差异太大则跳过
if (abs((int)doc1->word_count - (int)doc2->word_count) > threshold) {
    continue; // 跳过详细计算
}
```

### 3. 早停

在计算相似度时：

```c
double cosine_similarity_with_threshold(Document *doc1, Document *doc2, 
                                       double min_threshold) {
    // 计算部分相似度
    // 如果已经不可能超过阈值，提前返回
    if (partial_similarity < min_threshold * scale) {
        return 0.0;
    }
    // 继续完整计算...
}
```

## 内存占用优化

### 1. 使用紧凑数据结构

```c
// 32位整数代替指针（如果数据集不大）
typedef uint32_t NodeRef;

// 位域压缩标志
typedef struct {
    unsigned int is_valid : 1;
    unsigned int is_processed : 1;
    unsigned int reserved : 30;
} CompactFlags;
```

### 2. 延迟加载

```c
// 不保存原始文本内容
typedef struct Document {
    char filename[256];
    HashTable *word_freq;
    // char *content; // 删除，节省内存
    size_t word_count;
} Document;
```

### 3. 稀疏存储

只存储相似度 > 阈值的文档对：

```c
typedef struct SparseMatrix {
    size_t *row_indices;
    size_t *col_indices;
    double *values;
    size_t nnz; // 非零元素数量
} SparseMatrix;
```

## 性能监控

添加性能计时：

```c
#include <time.h>

clock_t start = clock();
// 执行操作
clock_t end = clock();
double time_spent = (double)(end - start) / CLOCKS_PER_SEC;
printf("操作耗时: %.3f 秒\n", time_spent);
```

## 最佳实践

1. **先测量后优化**：使用性能分析工具找到瓶颈
2. **权衡取舍**：性能、内存和代码复杂度之间平衡
3. **文档优化**：记录优化理由和性能提升
4. **回归测试**：确保优化不破坏功能
5. **渐进优化**：一次优化一个热点

## 参考资料

- [Agner Fog's Optimization Manuals](https://www.agner.org/optimize/)
- [Intel Intrinsics Guide](https://software.intel.com/sites/landingpage/IntrinsicsGuide/)
- [Valgrind Documentation](https://valgrind.org/docs/manual/)
- [perf Examples](http://www.brendangregg.com/perf.html)
